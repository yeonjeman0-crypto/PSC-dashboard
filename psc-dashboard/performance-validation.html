<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
    <title>PSC Dashboard - Performance Validation</title>
    
    <!-- Critical CSS for immediate render -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            color: #334155;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .metric-card {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-left: 4px solid #6366f1;
        }
        
        .metric-title {
            font-weight: 600;
            color: #475569;
            margin-bottom: 0.5rem;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        
        .metric-target {
            font-size: 0.875rem;
            color: #64748b;
        }
        
        .status-good { color: #10b981; }
        .status-warning { color: #f59e0b; }
        .status-poor { color: #ef4444; }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        
        .progress-fill {
            height: 100%;
            background: #10b981;
            transition: width 0.3s ease;
        }
        
        .test-results {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        
        .test-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .test-item:last-child {
            border-bottom: none;
        }
        
        .test-name {
            font-weight: 500;
        }
        
        .test-status {
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .status-pass {
            background: #dcfce7;
            color: #166534;
        }
        
        .status-fail {
            background: #fecaca;
            color: #991b1b;
        }
        
        .status-pending {
            background: #fef3c7;
            color: #92400e;
        }
        
        .controls {
            text-align: center;
            margin: 2rem 0;
        }
        
        .btn {
            background: #6366f1;
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            margin: 0 0.5rem;
            transition: background 0.2s;
        }
        
        .btn:hover {
            background: #5b21b6;
        }
        
        .btn:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }
        
        .log {
            background: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.875rem;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>PSC Dashboard Performance Validation</h1>
            <p>Real-time performance testing with <strong>&lt;3 second</strong> loading time target</p>
        </div>
        
        <!-- Core Web Vitals Metrics -->
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-title">Largest Contentful Paint (LCP)</div>
                <div class="metric-value" id="lcpValue">--</div>
                <div class="metric-target">Target: ≤2.5s</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="lcpProgress" style="width: 0%;"></div>
                </div>
            </div>
            
            <div class="metric-card">
                <div class="metric-title">First Input Delay (FID)</div>
                <div class="metric-value" id="fidValue">--</div>
                <div class="metric-target">Target: ≤100ms</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="fidProgress" style="width: 0%;"></div>
                </div>
            </div>
            
            <div class="metric-card">
                <div class="metric-title">Cumulative Layout Shift (CLS)</div>
                <div class="metric-value" id="clsValue">--</div>
                <div class="metric-target">Target: ≤0.1</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="clsProgress" style="width: 0%;"></div>
                </div>
            </div>
            
            <div class="metric-card">
                <div class="metric-title">Total Load Time</div>
                <div class="metric-value" id="loadTimeValue">--</div>
                <div class="metric-target">Target: ≤3.0s</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="loadTimeProgress" style="width: 0%;"></div>
                </div>
            </div>
        </div>
        
        <!-- System Performance Tests -->
        <div class="test-results">
            <h3>System Performance Tests</h3>
            <div id="testResults">
                <div class="test-item">
                    <span class="test-name">Service Worker Registration</span>
                    <span class="test-status status-pending" id="test-sw">Pending</span>
                </div>
                <div class="test-item">
                    <span class="test-name">State Management Initialization</span>
                    <span class="test-status status-pending" id="test-state">Pending</span>
                </div>
                <div class="test-item">
                    <span class="test-name">API Integration Setup</span>
                    <span class="test-status status-pending" id="test-api">Pending</span>
                </div>
                <div class="test-item">
                    <span class="test-name">Caching System Activation</span>
                    <span class="test-status status-pending" id="test-cache">Pending</span>
                </div>
                <div class="test-item">
                    <span class="test-name">Performance Optimization</span>
                    <span class="test-status status-pending" id="test-perf">Pending</span>
                </div>
                <div class="test-item">
                    <span class="test-name">Module Integration</span>
                    <span class="test-status status-pending" id="test-modules">Pending</span>
                </div>
                <div class="test-item">
                    <span class="test-name">System Integration Core</span>
                    <span class="test-status status-pending" id="test-integration">Pending</span>
                </div>
                <div class="test-item">
                    <span class="test-name">Sub-3-Second Loading Target</span>
                    <span class="test-status status-pending" id="test-target">Pending</span>
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div class="controls">
            <button class="btn" id="startTest" onclick="startPerformanceTest()">Start Performance Test</button>
            <button class="btn" id="loadDashboard" onclick="loadDashboard()" disabled>Load Dashboard</button>
            <button class="btn" onclick="clearLog()">Clear Log</button>
        </div>
        
        <!-- Performance Log -->
        <div class="test-results">
            <h3>Performance Log</h3>
            <div class="log" id="performanceLog">Waiting for performance test to start...</div>
        </div>
    </div>
    
    <script>
        class PerformanceValidator {
            constructor() {
                this.metrics = {
                    lcp: null,
                    fid: null,
                    cls: 0,
                    loadTime: null,
                    ttfb: null
                };
                
                this.testResults = {};
                this.testStartTime = null;
                this.logContainer = document.getElementById('performanceLog');
                
                this.setupPerformanceObserver();
            }
            
            setupPerformanceObserver() {
                if ('PerformanceObserver' in window) {
                    // Observe LCP
                    const lcpObserver = new PerformanceObserver((entryList) => {
                        const entries = entryList.getEntries();
                        const lastEntry = entries[entries.length - 1];
                        this.metrics.lcp = lastEntry.startTime;
                        this.updateMetricDisplay('lcp', this.metrics.lcp, 2500);
                        this.log(`LCP: ${this.metrics.lcp.toFixed(2)}ms`);
                    });
                    lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
                    
                    // Observe FID
                    const fidObserver = new PerformanceObserver((entryList) => {
                        const entries = entryList.getEntries();
                        entries.forEach(entry => {
                            this.metrics.fid = entry.processingStart - entry.startTime;
                            this.updateMetricDisplay('fid', this.metrics.fid, 100);
                            this.log(`FID: ${this.metrics.fid.toFixed(2)}ms`);
                        });
                    });
                    fidObserver.observe({ entryTypes: ['first-input'] });
                    
                    // Observe CLS
                    let clsValue = 0;
                    const clsObserver = new PerformanceObserver((entryList) => {
                        const entries = entryList.getEntries();
                        entries.forEach(entry => {
                            if (!entry.hadRecentInput) {
                                clsValue += entry.value;
                                this.metrics.cls = clsValue;
                                this.updateMetricDisplay('cls', this.metrics.cls, 0.1);
                                this.log(`CLS: ${this.metrics.cls.toFixed(3)}`);
                            }
                        });
                    });
                    clsObserver.observe({ entryTypes: ['layout-shift'] });
                    
                    // Observe navigation timing
                    const navObserver = new PerformanceObserver((entryList) => {
                        const entries = entryList.getEntries();
                        entries.forEach(entry => {
                            this.metrics.ttfb = entry.responseStart - entry.requestStart;
                            this.metrics.loadTime = entry.loadEventEnd - entry.navigationStart;
                            this.updateMetricDisplay('loadTime', this.metrics.loadTime, 3000);
                            this.log(`TTFB: ${this.metrics.ttfb.toFixed(2)}ms, Load Time: ${this.metrics.loadTime.toFixed(2)}ms`);
                        });
                    });
                    navObserver.observe({ entryTypes: ['navigation'] });
                }
            }
            
            async startPerformanceTest() {
                this.testStartTime = performance.now();
                this.log('🚀 Starting PSC Dashboard Performance Test...');
                
                document.getElementById('startTest').disabled = true;
                
                // Test sequence with timing
                const tests = [
                    { name: 'sw', func: () => this.testServiceWorker(), timeout: 3000 },
                    { name: 'state', func: () => this.testStateManagement(), timeout: 5000 },
                    { name: 'api', func: () => this.testAPIIntegration(), timeout: 3000 },
                    { name: 'cache', func: () => this.testCachingSystem(), timeout: 3000 },
                    { name: 'perf', func: () => this.testPerformanceSystem(), timeout: 3000 },
                    { name: 'modules', func: () => this.testModuleIntegration(), timeout: 5000 },
                    { name: 'integration', func: () => this.testSystemIntegration(), timeout: 5000 },
                    { name: 'target', func: () => this.testLoadingTarget(), timeout: 1000 }
                ];
                
                for (const test of tests) {
                    try {
                        this.log(`⏳ Testing ${test.name}...`);
                        const result = await Promise.race([
                            test.func(),
                            this.timeout(test.timeout)
                        ]);
                        
                        this.updateTestResult(test.name, true);
                        this.log(`✅ ${test.name} test passed`);
                    } catch (error) {
                        this.updateTestResult(test.name, false);
                        this.log(`❌ ${test.name} test failed: ${error.message}`);
                    }
                }
                
                const totalTime = performance.now() - this.testStartTime;
                this.log(`🏁 Performance test completed in ${totalTime.toFixed(2)}ms`);
                
                // Enable dashboard loading
                document.getElementById('loadDashboard').disabled = false;
                
                // Generate final report
                this.generateReport();
            }
            
            async testServiceWorker() {
                if ('serviceWorker' in navigator) {
                    const registration = await navigator.serviceWorker.register('../sw.js');
                    if (!registration) throw new Error('Service Worker registration failed');
                    return true;
                }
                throw new Error('Service Worker not supported');
            }
            
            async testStateManagement() {
                // Load state management script
                await this.loadScript('../src/assets/js/state-management.js');
                await this.waitForGlobal('StateManagement', 3000);
                
                if (!window.StateManagement?.global) {
                    throw new Error('State Management not properly initialized');
                }
                
                return true;
            }
            
            async testAPIIntegration() {
                await this.loadScript('../src/assets/js/api-integration-system.js');
                await this.waitForGlobal('PSC_API', 2000);
                
                if (!window.PSC_API?.getSystemHealth) {
                    throw new Error('API Integration not properly initialized');
                }
                
                return true;
            }
            
            async testCachingSystem() {
                await this.loadScript('../src/assets/js/caching-strategy-system.js');
                await this.waitForGlobal('CachingSystem', 2000);
                
                if (!window.CachingSystem?.getStatistics) {
                    throw new Error('Caching System not properly initialized');
                }
                
                return true;
            }
            
            async testPerformanceSystem() {
                await this.loadScript('../src/assets/js/performance-optimization-system.js');
                await this.waitForGlobal('PerformanceSystem', 2000);
                
                if (!window.PerformanceSystem?.getPerformanceStatus) {
                    throw new Error('Performance System not properly initialized');
                }
                
                return true;
            }
            
            async testModuleIntegration() {
                await this.loadScript('../src/assets/js/module-integration.js');
                await this.waitForGlobal('ModuleIntegrationManager', 3000);
                
                if (!window.ModuleIntegrationManager) {
                    throw new Error('Module Integration not properly initialized');
                }
                
                return true;
            }
            
            async testSystemIntegration() {
                await this.loadScript('../src/assets/js/system-integration-core.js');
                await this.waitForGlobal('SystemIntegration', 3000);
                
                if (!window.SystemIntegration?.getSystemStatus) {
                    throw new Error('System Integration not properly initialized');
                }
                
                // Wait for integration to complete
                let attempts = 0;
                while (attempts < 20) {
                    const status = window.SystemIntegration.getSystemStatus();
                    if (status.integration.status === 'completed') {
                        return true;
                    }
                    await this.delay(250);
                    attempts++;
                }
                
                throw new Error('System Integration did not complete in time');
            }
            
            async testLoadingTarget() {
                const totalLoadTime = performance.now() - this.testStartTime;
                
                if (totalLoadTime <= 3000) {
                    return true;
                } else {
                    throw new Error(`Loading time ${totalLoadTime.toFixed(2)}ms exceeds 3-second target`);
                }
            }
            
            updateMetricDisplay(metric, value, target) {
                const valueEl = document.getElementById(`${metric}Value`);
                const progressEl = document.getElementById(`${metric}Progress`);
                
                let displayValue, unit, percentage, status;
                
                switch (metric) {
                    case 'lcp':
                    case 'loadTime':
                        displayValue = (value / 1000).toFixed(2);
                        unit = 's';
                        percentage = Math.min((target - value) / target * 100, 100);
                        status = value <= target ? 'status-good' : value <= target * 1.5 ? 'status-warning' : 'status-poor';
                        break;
                    case 'fid':
                        displayValue = value.toFixed(0);
                        unit = 'ms';
                        percentage = Math.min((target - value) / target * 100, 100);
                        status = value <= target ? 'status-good' : value <= target * 2 ? 'status-warning' : 'status-poor';
                        break;
                    case 'cls':
                        displayValue = value.toFixed(3);
                        unit = '';
                        percentage = Math.min((target - value) / target * 100, 100);
                        status = value <= target ? 'status-good' : value <= target * 2 ? 'status-warning' : 'status-poor';
                        break;
                }
                
                if (percentage < 0) percentage = 0;
                
                valueEl.textContent = displayValue + unit;
                valueEl.className = `metric-value ${status}`;
                progressEl.style.width = `${percentage}%`;
                
                if (status === 'status-good') {
                    progressEl.style.background = '#10b981';
                } else if (status === 'status-warning') {
                    progressEl.style.background = '#f59e0b';
                } else {
                    progressEl.style.background = '#ef4444';
                }
            }
            
            updateTestResult(testName, passed) {
                const element = document.getElementById(`test-${testName}`);
                if (element) {
                    element.textContent = passed ? 'PASS' : 'FAIL';
                    element.className = `test-status ${passed ? 'status-pass' : 'status-fail'}`;
                }
                this.testResults[testName] = passed;
            }
            
            generateReport() {
                const passedTests = Object.values(this.testResults).filter(result => result).length;
                const totalTests = Object.keys(this.testResults).length;
                
                this.log('📊 PERFORMANCE VALIDATION REPORT');
                this.log('=' .repeat(50));
                this.log(`Tests Passed: ${passedTests}/${totalTests}`);
                
                if (this.metrics.lcp) {
                    this.log(`LCP: ${(this.metrics.lcp / 1000).toFixed(2)}s (Target: ≤2.5s) ${this.metrics.lcp <= 2500 ? '✅' : '❌'}`);
                }
                
                if (this.metrics.fid) {
                    this.log(`FID: ${this.metrics.fid.toFixed(0)}ms (Target: ≤100ms) ${this.metrics.fid <= 100 ? '✅' : '❌'}`);
                }
                
                this.log(`CLS: ${this.metrics.cls.toFixed(3)} (Target: ≤0.1) ${this.metrics.cls <= 0.1 ? '✅' : '❌'}`);
                
                if (this.metrics.loadTime) {
                    this.log(`Total Load: ${(this.metrics.loadTime / 1000).toFixed(2)}s (Target: ≤3.0s) ${this.metrics.loadTime <= 3000 ? '✅' : '❌'}`);
                }
                
                const overallPass = passedTests === totalTests && 
                                  (this.metrics.loadTime ? this.metrics.loadTime <= 3000 : true);
                
                this.log('=' .repeat(50));
                this.log(`OVERALL RESULT: ${overallPass ? 'PASS ✅' : 'FAIL ❌'}`);
                
                if (overallPass) {
                    this.log('🎉 PSC Dashboard meets sub-3-second performance target!');
                } else {
                    this.log('⚠️ Performance optimization needed');
                }
            }
            
            // Utility methods
            async loadScript(src) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = () => reject(new Error(`Failed to load ${src}`));
                    document.head.appendChild(script);
                });
            }
            
            async waitForGlobal(name, timeout = 3000) {
                const startTime = Date.now();
                
                while (!window[name]) {
                    if (Date.now() - startTime > timeout) {
                        throw new Error(`Timeout waiting for ${name}`);
                    }
                    await this.delay(100);
                }
                
                return window[name];
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            timeout(ms) {
                return new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Timeout')), ms);
                });
            }
            
            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                console.log(logEntry);
                
                this.logContainer.textContent += logEntry + '\n';
                this.logContainer.scrollTop = this.logContainer.scrollHeight;
            }
        }
        
        // Global instance
        let performanceValidator;
        
        // Functions for buttons
        function startPerformanceTest() {
            if (!performanceValidator) {
                performanceValidator = new PerformanceValidator();
            }
            performanceValidator.startPerformanceTest();
        }
        
        function loadDashboard() {
            window.location.href = './integrated-index.html';
        }
        
        function clearLog() {
            document.getElementById('performanceLog').textContent = 'Log cleared...\n';
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            performanceValidator = new PerformanceValidator();
            performanceValidator.log('Performance Validator initialized. Click "Start Performance Test" to begin.');
        });
    </script>
</body>
</html>